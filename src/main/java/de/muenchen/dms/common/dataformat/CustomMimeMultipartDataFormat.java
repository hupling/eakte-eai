package de.muenchen.dms.common.dataformat;

import jakarta.activation.DataHandler;
import jakarta.mail.BodyPart;
import jakarta.mail.Header;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.ContentType;
import jakarta.mail.internet.InternetHeaders;
import jakarta.mail.internet.MimeBodyPart;
import jakarta.mail.internet.MimeMultipart;
import jakarta.mail.internet.MimeUtility;
import jakarta.mail.internet.ParseException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.attachment.AttachmentMessage;
import org.apache.camel.attachment.DefaultAttachment;
import org.apache.camel.dataformat.mime.multipart.MimeMultipartDataFormat;
import org.apache.camel.support.MessageHelper;
import org.apache.camel.util.IOHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;

@AllArgsConstructor
@Getter
@Setter
public class CustomMimeMultipartDataFormat extends MimeMultipartDataFormat {
  private static final Logger LOG = LoggerFactory.getLogger(CustomMimeMultipartDataFormat.class);
  private static final String MIME_VERSION = "MIME-Version";
  private static final String CONTENT_TYPE = "Content-Type";
  private static final String DEFAULT_CONTENT_TYPE = "application/octet-stream";
  private static final String[] STANDARD_HEADERS = {"Message-ID", "MIME-Version", "Content-Type"};
  private boolean headersInline;
  private String bodyDispositionName;

  @Override
  public Object unmarshal(Exchange exchange, InputStream stream)
      throws IOException, MessagingException {
    MimeBodyPart mimeMessage;
    String contentType;
    Message camelMessage;
    Object content = null;
    if (headersInline) {
      mimeMessage = new MimeBodyPart(stream);
      camelMessage = exchange.getMessage();
      MessageHelper.copyHeaders(exchange.getIn(), camelMessage, true);
      // write the MIME headers not generated by javamail as Camel headers
      Enumeration<?> headersEnum = mimeMessage.getNonMatchingHeaders(STANDARD_HEADERS);
      while (headersEnum.hasMoreElements()) {
        Object ho = headersEnum.nextElement();
        if (ho instanceof Header) {
          Header header = (Header) ho;
          camelMessage.setHeader(header.getName(), header.getValue());
        }
      }
    } else {
      // check if this a multipart at all. Otherwise do nothing
      contentType = exchange.getIn().getHeader(CONTENT_TYPE, String.class);
      if (contentType == null) {
        return stream;
      }
      try {
        ContentType ct = new ContentType(contentType);
        if (!ct.match("multipart/*")) {
          return stream;
        }
      } catch (ParseException e) {
        LOG.warn("Invalid Content-Type {} ignored", contentType);
        return stream;
      }
      camelMessage = exchange.getMessage();
      MessageHelper.copyHeaders(exchange.getIn(), camelMessage, true);
      ByteArrayOutputStream bos = new ByteArrayOutputStream();
      IOHelper.copyAndCloseInput(stream, bos);
      InternetHeaders headers = new InternetHeaders();
      extractHeader(CONTENT_TYPE, camelMessage, headers);
      extractHeader(MIME_VERSION, camelMessage, headers);
      mimeMessage = new MimeBodyPart(headers, bos.toByteArray());
      bos.close();
    }
    DataHandler dh;
    try {
      dh = mimeMessage.getDataHandler();
      if (dh != null) {
        content = dh.getContent();
      }
    } catch (MessagingException e) {
      LOG.warn("cannot parse message, no unmarshalling done");
    }
    if (content instanceof MimeMultipart) {
      MimeMultipart mp = (MimeMultipart) content;
      boolean foundBody = false;
      for (int i = 0; i < mp.getCount(); i++) {
        BodyPart bp = mp.getBodyPart(i);
        String[] disposition = bp.getHeader(HttpHeaders.CONTENT_DISPOSITION);
        String dispositionName = disposition[0];
        if (dispositionName.contains(String.format("name=\"%s\"", this.bodyDispositionName))) {
          content = bp;
          foundBody = true;
        } else {
          DefaultAttachment camelAttachment = new DefaultAttachment(bp.getDataHandler());
          @SuppressWarnings("unchecked")
          Enumeration<Header> headers = bp.getAllHeaders();
          while (headers.hasMoreElements()) {
            Header header = headers.nextElement();
            camelAttachment.addHeader(header.getName(), header.getValue());
          }
          camelMessage
              .getExchange()
              .getMessage(AttachmentMessage.class)
              .addAttachmentObject(getAttachmentKey(bp), camelAttachment);
        }
        if (!foundBody) {
          content = null;
        }
      }
    }
    if (content == null) {
      camelMessage.setBody(null);
    } else if (content instanceof BodyPart) {
      BodyPart bp = (BodyPart) content;
      camelMessage.setBody(bp.getInputStream());
      contentType = bp.getContentType();
      if (contentType != null && !DEFAULT_CONTENT_TYPE.equals(contentType)) {
        camelMessage.setHeader(CONTENT_TYPE, contentType);
        ContentType ct = new ContentType(contentType);
        String charset = ct.getParameter("charset");
        if (charset != null) {
          camelMessage.setHeader(Exchange.CONTENT_ENCODING, MimeUtility.javaCharset(charset));
        }
      }
    } else {
      // If we find no body part, try to leave the message alone
      LOG.info("no MIME part found");
    }
    return camelMessage;
  }

  private void extractHeader(String headerMame, Message camelMessage, InternetHeaders headers) {
    String h = camelMessage.getHeader(headerMame, String.class);
    if (h != null) {
      headers.addHeader(headerMame, h);
      camelMessage.removeHeader(headerMame);
    }
  }

  private String getAttachmentKey(BodyPart bp)
      throws MessagingException, UnsupportedEncodingException {
    // use the filename as key for the map
    String key = bp.getFileName();
    // if there is no file name we use the Content-ID header
    if (key == null && bp instanceof MimeBodyPart) {
      key = ((MimeBodyPart) bp).getContentID();
      if (key != null && key.startsWith("<") && key.length() > 2) {
        // strip <>
        key = key.substring(1, key.length() - 1);
      }
    }
    // or a generated content id
    if (key == null) {
      key = UUID.randomUUID() + "@camel.apache.org";
    }
    return MimeUtility.decodeText(key);
  }
}
